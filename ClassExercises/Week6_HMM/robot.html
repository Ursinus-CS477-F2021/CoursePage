<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<!-- Header !-->
	<head>
		<title>Ursinus CS 477: Artificial Intelligence And Machine Learning, Fall 2021</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<!--[if lte IE 8]><script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="../../assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="../../assets/css/ie8.css" /><![endif]-->
        <style>
        .image_off, #home:hover .image_on{
           display:none
        }
        .image_on, #home:hover .image_off{
           display:block
        }
        </style>
	</head>
	<body>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../index.html" class="logo"><strong>Ursinus CS 477: Artificial Intelligence And Machine Learning, Fall 2021</strong></a>
								</header>
<!-- End Header !-->

							<!-- Content -->
								<section>
									<header class="main">
                                        <h2>Week 6: Bayesian Robot Localization</h2>
                                        <h3><a href = "http://www.ctralie.com">Chris Tralie</a></h3>
									</header>

									<div id="page-content">
										<p>
											<b>NOTE: </b> We'll spend the better part of two days on this exercise, and it will help get you ready for the next mini assignment
										</p>
                                        <p>
											The purpose of this exercise is to get you practice with the Viterbi algorithm for finding an optimal sequence of states through a Hidden Markov Model (HMM).  In this case, the hidden states are the <b>position of a robot in 2D</b>, and the observations are <b>omnidirectional range scans</b>.  This is an idealized model of a real "LIDAR scanner" such as the <a href = "https://hokuyo-usa.com/products/lidar-obstacle-detection/urg-04lx">Hokuyo URG-04LX laser range scanner</a>, which is able to sweep a laser in a 270 degree field of view in front of it
										</p>

										<img src = "URG-04LX.jpg" width=250>

										<p>
											For this exercise, I've created a synthetic robot that can move right/left/up/down on a 2D grid, and which is always oriented the same way.  Below is an image of this robot moving around.  The ground truth position of the robot (the hidden state) is shown on the left on a map of the environment, while the laser scan (observation) is shown on the right
										</p>

										<img src = "clean_scan.gif">

										<p>
											The above is an idealized example, however, because the scan is rarely this perfect.  Usually there is noise that <i>perturbs</i> the true range measurements; that is, we end up measuring that a wall is either closer or further than it actually is at a particular angle.  We'll model the noise here as a multiplicative Gaussian; that is, if the ground truth range is <b>r</b>, then the observed range <b>m(r)</b> is 
										</p>

										<h3>
											\[ m(r) = r(1 + \alpha n)\]
										</h3>

										<p>
											where <b>n</b> is a "standard Gaussian distributed" random variable with distribution 
										</p>

										<h3>
											\[ n \sim \frac{1}{\sqrt{2 \pi}} e^{-n^2/2} \]
										</h3>

										<p>
											and <b>&alpha;</b> is some parameter set ahead of time.  In other words, the further away the measurement is, the more it can be perturbed.  Below is the code I used to sample from this noise model, taking advantage of numpy's built in <code><a href = "https://numpy.org/doc/stable/reference/random/generated/numpy.random.randn.html">randn</a></code> method for sampling random variables from the standard Gaussian
										</p>

										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											scan[i] = range*(1+alpha*np.random.randn())
										</script>  

										<p>
											Below is an example where <b>&alpha; = 0.2</b>
										</p>

										<img src = "noisy_scan.gif">

										<p>
											Below is an example where <b>&alpha; = 2</b>
										</p>

										<img src = "verynoisy_scan.gif">

										<p>
											At this level of noise, it seems like we're hardly getting any useful information.  However, amazingly, if you use the above sensor model and assume that the robot is equally likely to visit any of its neighbors, then you can actually recover a pretty good estimate of the robot's trajectory using the Viterbi algorithm.  Below is a plot of the original trajectory next to what the algorithm recovered here (NOTE: results may vary based on the noise samples):
										</p>

										<img src = "Est_VeryNoisy.svg">

										<p>
											This is the power of <b>sequence modeling</b>; even if our measurements are total crap at a particular instant in time, if they have even a little bit of signal, then we can "boost" the signal strength by looking at many states in sequence.
										</p>

										<HR>
											<h2>Programming Task</h2>
											<p>
												<a href = "https://github.com/Ursinus-CS477-F2021/Week6_RobotLocalization/archive/refs/heads/main.zip">Click here</a> to download the starter code for this exercise.  
											</p>

											<p>
												Below is some code you can use to initialize a world and to simulate the scans of a trajectory through that world
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												## Step 1: Create the world and devise robot motion
												# Load in a particular environment
												env = Environment("Maze1.png")
												# Devise a path through that environment
												X = env.simulate_trajectory([[13, 26], [28, 5], [39, 29]])
												# Plot the environment with the path superimposed
												plt.figure()
												env.plot()
												plt.plot(X[:, 0], X[:, 1])

												## Step 2: Simulate scans at each position
												# How many angles to sample in the range scanner
												res = 100 
												# The noise of the scanner (start with 0 to make the problem easier)
												alpha = 0 
												# Create a list of scans.  Each scan holds a list of "res" laser ranges
												observed_scans = [env.get_range_scan(X[i, :], res, alpha) for i in range(X.shape[0])]

											</script>  

											<p>
												Next, you'll need to figure out what perfect observations look like at each grid cell in the world so you can figure out the probability that you observed a scan given that you were at a particular cell.  There are <b>N</b> open grid cells in the world indexed from <b>0</b> to <b>N-1</b>, and the robot can be at any one of them at any time.  The member variable <code>X</code> of the <code>env</code> object is a 2D array that holds their positions, so <code>X[i]</code> gives the <code>[x, y]</code> coordinate list for the ith point.  Therefore, the code below will create a list of all perfect range scans from each position in the world
											</p>



											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												N = len(env.X)
												state_scans = [env.get_range_scan(env.X[i], res, alpha=0) for i in range(N)]
											</script> 
											
											<p>
												Finally, there's a list member variable <code>env.neighbors</code>, where <code>env.neighbors[i]</code> lists the indices of the neighbors of state <code>i</code>. 
											</p>
											<p>
												Now, you have all of the information you need to extract the optimal sequence of states using the Viterbi algorithm!  Let's say you come up with a list of state indices called <code>states</code>.  Then the following code will extract and plot the coordinates of the trajectory you estimated on top of the "ground truth" (correct) trajectory
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												states = np.array(states, dtype=int)
												Y = env.X[states, :]
												plt.figure()
												plt.plot(X[:, 0], X[:, 1], 'k', linewidth=4)
												plt.plot(Y[:, 0], Y[:, 1], 'C1', linestyle='--')
												plt.legend(["Ground Truth", "Estimated"])
												plt.axis("equal")
												plt.title("Estimated Trajectory, $\\alpha={:.3f}$".format(alpha))
											</script> 

											<p>
												First try to make sure you can handle the case where &alpha; = 0, then ratchet up the noise and see how much noise the algorithm can take and still give a good result.
											</p>


										<HR>
											<h2>For The Bored...</h2>
											<p>
												If you finish this early, here are a few things you can try
											</p>
											<ul>
												<li>
													In addition to modeling the position, allow the robot to rotate.  How would you change your state space?  How would you update your observations to handle a rotation?
												</li>
												<li>
													Think about how you might store some "second order" information about where the robot has been like velocity.  If we assume the law of inertia, the robot is more likely to continue moving in the direction of its velocity than it is to make a sudden turn, so you can use non-uniform transition probabilities to neighbors.
												</li>
											</ul>


                                    
                                </div>
						</div>
					</div>

					<!--LaTeX in Javascript!-->
					<script src="../../../../jsMath/easy/load.js"></script>
					<!--Syntax highlighting in Javascript!-->
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shCore.js"></script>
					<script type="text/javascript" src="../../../syntaxhighlighter/scripts/shBrushJScript.js"></script>
                    <script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushCpp.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushXml.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushMatlabSimple.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushPython.js"></script>
					<link type="text/css" rel="stylesheet" href="../../../../syntaxhighlighter/styles/shCoreDefault.css"/>
					<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
                                        <li>
											<span class="opener">General</span>
											<ul>
												<li><a href = "../../index.html#overview">Overview</a></li>
												<li><a href = "../../index.html#logistics">Technology Logistics</a></li>
												<li><a href = "../../index.html#readings">Readings</a></li>
												<li><a href = "../../index.html#deliverables">Deliverables</a></li>
												<li><a href = "../../index.html#schedule">Schedule</a></li>
												<li><a href = "../../index.html#grading">Grading</a></li>
												<li><a href = "../../index.html#environment">Classroom Environment</a></li>
												<li><a href = "../../index.html#collaboration">Collaboration Policy</a></li>
												<li><a href = "../../index.html#other">Other Resources / Policies</a></li>
											</ul> 
										</li>
										<li><a href = "../../Software/index.html">Software</a></li>
										<li><a href = "../../index.html#schedule">Schedule</a></li>
                                        <li>
											<span class="opener">Assignments</span>
											<ul>
												<li>
													<a href = "https://ursinus-cs477-f2021.github.io/Modules/Module1/Video1">HW0: Python Self Study Module</a>
												</li>
												<li>
													<a href = "../../Assignments/HW1_WelcomeToCS477">HW1: Welcome To CS 477</a>
												</li>
												<li>
													<a href = "../../Assignments/HW2_RushHour">HW2: The Rush Hour Problem</a>
												</li>
												<li>
													<a href = "../../Assignments/HW3_Markov">HW3: Markov Chains for Text Processing</a>
												</li>
											</ul>
										</li>
                                        <li>
											<span class="opener">Class Exercises / Notes</span>
											<ul>
												<li>
													<a href = "../../ClassExercises/Week1_WhatIsAI">Week 1: What Is AI?</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week1_Adventure">Week 1: Choose Your Own Adventure</a>
													<ul>
														<li><a href = "../../ClassExercises/Week1_Adventure/index.html#student">Student Adventures</a></li>
													</ul>
												</li>
												<li>
													<a href = "../../ClassExercises/Week1_COVID">Week 1: Monte Carlo COVID Simulation</a>
													<ul>
														<li><a href = "../../ClassExercises/Week1_COVID/solution.html">Solution</a></li>
													</ul>
												</li>
												<li>
													<a href = "../../ClassExercises/Week2_BasicSearch">Week 2: Blind Maze Searching</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week2_8Puzzle">Week 2: 8 Puzzle</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week3_PrioritySearch">Week 3: Uniform Cost, Greedy Best-First, and A* Search</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week4_Markov">Week 4: Markov Chains of Characters</a>
												</li>
												<li>
													<a href = "https://ursinus-cs477-f2021.github.io/Modules/Module2/Video1">Week 5: Probability Module</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week5_BagOfWords">Week 5: Bag of Words Exercise / Theory of Bayesian Classifiers</a>
													<ul>
														<li><a href = "../../ClassExercises/Week5_BagOfWords#exercise">Text Classification Exercise</a></li>
														<li><a href = "../../ClassExercises/Week5_BagOfWords#theory">Naive Bayes Theory</a></li>
													</ul>
												</li>
												<li>
													<a href = "https://ursinus-cs477-f2021.github.io/Modules/Module3/Exercise0">Week 5: Bayes Module</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week6_GradSchoolAdmissions">Week 6: Gaussian Naive Bayes And Grad School Admissions</a>
												</li>
												<li>
													<a href = "../../ClassExercises/Week6_HMM/robo.html">Week 6: Bayesian Robot Localization</a>
												</li>
											</ul>
										</li>
									</ul>
								</nav>


							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">&copy; <a href = "http://www.ctralie.com">Christopher J. Tralie</a>. All rights reserved.  Contact chris.tralie@gmail.com. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>
			
            <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- End Sidebar !-->

<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/skel.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="../../assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="../../assets/js/main.js"></script>
<!-- End Scripts -->
